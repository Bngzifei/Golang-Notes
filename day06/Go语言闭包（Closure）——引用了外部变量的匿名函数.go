// go语言的匿名函数就是一个闭包,闭包是可以包含自由(未绑定到特定对象)变量的代码块,这些变量不在这个代码块内或者任何全局上下文中定义,而是在定义代码块的环境中定义.要执行的代码块(由于自由变量包含在代码块中,所以这些自由变量以及它们引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)

// 闭包的价值在于可以作为函数对象或者匿名函数,对于类型系统而言,这意味着不仅要表示数据还要表示代码.支持闭包的多数语言都将函数作为第一级对象,就是说这些函数可以存储到变量中作为参数传递给其他函数,最重要的是能够被函数动态创建和返回.

// Go语言中的闭包同样也会引用到函数外的变量.闭包的实现确保只要闭包还被使用,那么被闭包引用的变量会一直存在.因此,简单的说:
// 函数 + 引用环境 = 闭包

// 同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示。

// 一个函数类型就像结构体一样,可以被实例化.函数本身不存储任何信息,只有与引用环境结合后形成的闭包才具有"记忆性".函数是编译期静态的概念,而闭包是运行期动态的概念.

// 其它编程语言中的闭包
// 闭包(Closure)在某些编程语言中也被称为Lambda表达式

// 闭包对环境中变量的引用过程,也可以被称为"捕获",在 C++11标准中,捕获有两种类型:引用和复制,可以改变引用的原值叫做"引用捕获",捕获的过程值被复制到闭包中的使用叫做"复制捕获"

// 在lua语言中,将被捕获的变量起了一个名字Upvalue,因为捕获过程总是对闭包上方定义过的自由变量进行引用.

// 闭包在各种语言中的实现也是不尽相同的.在lua语言中,无论闭包还是函数都属于Prototype概念,别捕获的变量以Upvalue的形式引用到闭包中.

// C++与C#中为闭包创建了一个类,而被捕获的变量在编译时放到类中的成员中,闭包在访问被捕获的变量时,实际上访问的是闭包隐藏类的成员.

// 在闭包内部修改引用的变量
// 闭包对它作用域上部的变量的引用可以进行修改,修改引用的变量就会对变量进行实际修改,通过下面的例子来理解:
package main

import (
	"fmt"
)

func main() {

	// 准备一个字符串
	str := "hello world"
	// 创建一个匿名函数
	foo := func() {
		// 匿名函数中访问str
		str = "hello dude"
		fmt.Println(str)
	}

	// 调用匿名函数
	foo()
}

// 代码说明如下：
// 第 2 行，准备一个字符串用于修改。
// 第 5 行，创建一个匿名函数。
// 第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。
// 第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。

// 代码输出：
// hello dude。
