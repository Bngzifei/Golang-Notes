// 结构体在实例化时可以直接对成员变量进行初始化.初始化有两种形式:一种是字段"键值对"形式及多个值的列表形式.键值对形式的初始化适合选择性填充字段较多的结构体;多个值的列表形式适合填充字段较少的结构体.

// 使用"键值对"初始化结构体

// 结构体可以使用"键值对"(Key value pair) 初始化字段,每个"键"(Key)对应结构体中的一个字段.键的"值"(Value)对应字段需要初始化的值.

// 键值对的填充是可选的,不需要初始化的字段可以不填入初始化列表中.

// 结构体实例化后的字段的默认值是字段类型的默认值,例如:数值为0,字符串为空字符串,布尔类型为false,指针为nil等

// 1)键值对初始化结构体的书写格式
// 键值对初始化的格式如下:

ins := 结构体类型名{
    字段1:字段1的值,
    字段2:字段2的值,
    ...
}
// 下面是对各个部分的说明:
// # 结构体类型:定义结构体时的类型名称
// #字段1,字段2:结构体的成员字段名.结构体类型名的字段初始化列表中,字段名只能出现一次.

// #字段1的值,字段2的值:结构体成员字段的初始值
// 键值之间以:分隔;键值对之间以,分隔

// 2)使用键值对填充结构体的例子
// 下面的例子描述了家里的人物关联.正如儿歌里唱的:"爸爸的爸爸是爷爷",人物之间可以使用多级的child来描述和建立关联.使用键值对形式填充结构体的代码如下:

type People struct {
    name string
    child *People
}

relation := &People{
    name:"爷爷",
    child:&People{
        name:"我"
    }
}

// 代码说明如下:
// 第1行,定义People结构体
// 第2行,结构体的字符串字段
// 第3行,结构体的结构体指针字段,类型是*People
// 第6行,relation由People类型取地址后,形成*People的实例
// 第8行,child在初始化时,需要*People类型的值.使用取地址初始化一个People

// 结构体成员中只能包含结构体的指针类型,包含非指针类型会引起编译错误

// 使用多个值的列表初始化结构体
// Go语言可以在"键值对"初始化的基础上忽略"键".也就是说,可以使用多个值的列表初始化结构体的字段.


// 1)多个值列表初始化结构体的书写格式
// 多个值使用逗号分隔初始化结构体,例如:
// ins := 结构体类型名{
//     字段1的值,
//     字段2的值,
//     ...
// }

// 使用这种格式初始化时,需要注意:
// 1.必须初始化结构体的所有字段。
// 2.每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。
// 3.键值对于值列表的初始化形式不能混用。


// 2.）多个值列表初始化结构体的例子
// 下面的例子描述了一段地址结构。地址要求具有一定的顺序。例如：

type Address struct {
    provice string
    City   string
    ZipCode  int
    PhoneNumber   string
}


addr := Address {
    "四川",
    "成都",
    610000,
    "0",
}

fmt.Println(addr)

运行代码如下,输出如下:{四川 成都 610000 0}

初始化匿名结构体:
// 匿名结构体没有类型名称,无须通过type关键字定义就可以使用
1)匿名结构体定义格式和初始化写法
匿名结构体的初始化写法由定义和键值对初始化两部分组成.结构体定义时没有结构体类型名.只有字段和类型定义.键值对初始化部分由可选的多个键值对组成,如下格式所示:

ins := struct {
    // 匿名结构体字段定义
    字段1 字段类型1
    字段2 字段类型2
    ...
}{
   // 字段值初始化
   初始化字段1:字段1的值
   初始化字段2:字段2的值
   ...

}
下面是对各个部分的说明:
1.字段1,字段2....:结构体定义的字段名
2.初始化字段1,初始化字段2....:结构体初始化时的字段名,可选择性地对字段初始化.
3.字段类型1,字段类型2...:结构体定义字段的类型
4.字段1的值,字段2的值...:结构体初始化字段的初始值.


键值对初始化部分是可选的,不初始化成员时,匿名结构体的格式变为:
ins := struct {
    字段1字段类型1
    字段2字段类型2
    ...
}

// 2)使用匿名结构体的例子
在本例中,使用结构体的方式和初始化一个消息结构,这个消息结构具有消息标示部分(ID)和数据部分(data).打印消息内容的printMsg()函数在接收匿名结构体时需要在参数上重新定义匿名结构体,代码如下:

package main  

import (
    "fmt"
)

// 打印消息类型,传入匿名结构体
func printMsgType(msg *struct {
    id int
    data string
}) {
    // 使用动词%T打印msg的类型
    fmt.Printf("%T\n",msg)
}

func main() {
    // 实例化一个匿名结构体
    msg := &struct {
        //定义部分
        1024,
        "hello",
    }

    printMsgType(msg)
}

// 代码输出如下:
*struct{id int;data string}

代码说明如下:
第8行,定义printMsgType()函数,参数为msg,类型为*struct{id int data string}.因为类型没有使用type定义,所以需要在用到的地方每次进行定义.
第14行,使用字符串格式化中的%T动词,将msg的类型名打印出来.
第20行,对匿名结构体进行实例化,同时初始化成员
第21和22行,定义匿名结构体的字段
第24和25行,给匿名结构体字段赋予初始值
第28行,将msg传入printMsgType()函数中进行函数调用.

匿名结构体的类型名是结构体包含字段成员的详细描述.匿名结构体在使用时需要重新定义,造成大量重复的代码,因此开发中较少使用.
























http://c.biancheng.net/view/67.html
proxy-switchyomega插件地址:
https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif

