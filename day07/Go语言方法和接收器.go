// 在Go语言中,结构体就像是类的一种简化形式,那么面向对象程序员可能会问:类的方法在哪里呢?在Go语言中有一个概念,它和方法有着同样的名字,并且大体上意思相同:Go方法是作用在接收器receiver上的一个函数,接收器是某种类型的变量.因此方法是一种特殊类型的函数.

// 接收器类型可以是(几乎)任何类型,不仅仅是结构体类型:任何类型都可以有方法,甚至可以是函数类型,可以是int,bool,string或数组的别名类型.但是接收器不能是一个接口类型,因为接口是一个抽象定义,但是方法却是具体实现;如果这样做会引发一个编译错误:invalid receiver type...

// 最后接收器不能是一个指针类型,但是它可以是任何其他允许类型的指针.一个类型加上它的方法等价于面向对象中的一个类.一个重要的区别是:在Go语言中,类型的代码和绑定在它上面的方法的代码可以不放置在一起,它们可以存在于不同的源文件,唯一的要求是:它们必须是同一个包的.


// 类型T或T上的所有方法的集合叫做类型T或T的方法集

// 因为方法是函数,所以同样的,不允许方法重载,即对于一个类型只能有一个给定名称的方法.但是如果基于接收器类型,是有重载的:具有同样名字的方法可以在2个或多个不同的接收器类型上存在,比如在同一个包里这么做是允许的.

// 提示:

// 在面向对象的语言中,类拥有的方法一般被理解为类可以做的事情.在Go语言中"方法"的概念与其他语言一致,只是Go语言建立的"接收器"强调方法的作用对象是接收器,也就是类实例,而函数没有作用对象


// 为结构体添加方法
// 本节中,将会使用背包作为"对象",将物品放入背包的过程作为"方法",通过面向过程的方式和Go语言中结构体的方式来理解"方法"的概念.

// 1)面向过程实现方法:
// 面向过程中没有"方法"概念,只能通过结构体和函数,由使用者使用函数参数和调用关系来形成接近"方法"的概念.代码如下:

type Bag struct {
    items []int
}

// 将一个物品放入背包的过程
func Insert(b *Bag,itemid int) {
    b.items = append(b.items,itemid)
}


func main() {
    bag := new(Bag)

    Insert(bag,1001)
}

// 代码说明如下:
// 第1行,声明Bag结构,这个结构体包含一个整型切片类型的items的成员
// 第6行,定义了Insert()函数,这个函数拥有两个参数,第一个参数是背包指针(*Bag),第二个是物品ID(itemid)

// 第7行,用append()将itemid添加到Bag的items成员中,模拟往背包添加物品的过程.
// 第12行,创建背包实例bag.
// 第14行,调用Insert()函数,第一个参数放入背包,第二个参数放入物品ID

// Insert()函数将*Bag参数放在第一位,强调Insert会操作*Bag结构体,但实际使用中,并不是每个人都会习惯将操作对象放在首位,一定程度上让代码失去一些范式和描述性.同时,Insert()函数也与Bag没有任何归属概念.随着类似Insert()的函数越来越多,面向过程的代码描述对象的方法概念会越来越麻烦和难以理解.

2)Go语言的结构体方法
将背包及放入背包的物品中使用Go语言的结构体和方法方式编写:为*Bag创建一个方法,代码如下:

type Bag struct {
    items []int
}

func (b *Bag)  Insert(itemid int) {
   b.items = append(b.items,itemid)
}

func main(){
    b := new(Bag)

    b.Insert(1001)
}

// 第5行中,Insert(itemed int)的写法与函数一致.(b*Bag)表示接收器,即Insert作用的对象实例.


// 第13行中,在insert()转换为方法后,我们就可以愉快地像其他语言一样,用面向对象的方法来调用b的insert


// 接收器----方法作用的目标

// 接收器的格式如下:

// func (接收器变量 接收器类型) 发明(参数列表) (返回参数) {
//     函数体
// }

// 对各部分的说明:

// 1.接收器变量:接收器中的参数变量名在命名时,官方建议使用接收器类型名的第一个小写字母,而不是self,this之类的命名.例如,Socket类型的接收器变量应该命名为s,Connector类型的接收器变量应该命名为c等.
// 2.接收器类型:接收器类型和参数类似,可以是指针类型和非指针类型

// 3.方法名,参数列表,返回参数:格式与函数定义一致

// 接收器根据接收器的类型可以分为指针接收器,非指针接收器.两种接收器在使用时会产生不同的效果.根据效果的不同,两种接收器会被用于不同性能和功能要求的代码中.

// 1)理解指针类型的接收器

// 指针类型的接收器由一个指针组成,更接近于面向对象中的this或者self

// 由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。

// 在下面的例子,使用结构体定义一个属性(Property),为属性添加SetValue()方法以封装设置属性的过程,通过属性的Value()方法可以重新获得属性的数值.使用属性时,通过SetValue方法的调用,可以达成修改属性值的效果.

package main

import (
    "fmt"
)

// 定义属性结构
type Property struct {
    value int //属性值
}

//设置属性值
func (p *Property) SetValue(v int) {
    // 修改p的成员变量
    p.value = v
}

// 取属性值
func (p *Property) Value() int {
    return p.value
}


func main() {
    // 实例化属性
    p := new(Property)

    // 设置值
    p.SetValue(100)

    // 打印值
    fmt.Println(p.Value())
}


// 运行程序,输出如下:
100

// 代码说明如下:
// 第6行,定义一个属性结构,拥有一个整型的成员变量.
// 第11行,定义属性值的方法
// 第14行,设置属性值方法的接收器类型为指针.因此可以修改成员值,即便退出方法,也有效.
// 第18行,定义获取值的方法.
// 第25行,实例化属性结构
// 第28行,设置值.此时成员变量变为100
// 第31行,获取成员变量


// 2)理解非指针类型的接收器
// 当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。

// 点（Point)使用结构体描述时,为点添加Add()方法,这个方法不能修改Point的成员X,Y变量,而是在计算后返回新的Point对象.Point属于效内存对象,在函数返回值的复制过程中可以极大的提高代码运行效率,详细过程参考下面的代码:


package main 

import (
    "fmt"
)

// 定义点结构

type Point struct {
    X int 
    Y int 
}


// 非指针接收器的加方法
func (p Point) Add(other Point) Point {
    // 成员值与参数相加后返回新的结构
    return Point {p.X + other.X,p.Y+other.Y}
}


func main() {
    // 初始化点
    p1 := Point{1,1}
    p2 := Point{2,2}

    // 与另外一个点相加
    result := p1.Add(p2)

    // 输出结果
    fmt.Println(result)
}

// 代码输出如下:
{3 3}

// 代码说明如下:
// 第8行,定义一个点结构,拥有X和Y两个整型分量

// 第14行,为Point结构定义一个Add()方法.传入和返回都是点的结构,可以方便地实现多个点连续相加的效果,例如:
// P4 := P1.Add(P2).Add(P3)

// 第23和24行,初始化两个点p1和p2
// 第27行,将p1和p2相加后返回结果
// 第30行,打印结果

// 由于例子中使用非指针接收器,Add()方法变得类似于只读的方法,Add()方法内部不会对成员进行任何修改.

// 3)指针和非指针接收器的使用
// 在计算机中,小对象由于值复制时的速度较快,所以适合使用非指针接收器.大对象因为复制性能较低,适合使用指针接收器,在接收器和参数间传递时不进行复制,只是传递指针.










































