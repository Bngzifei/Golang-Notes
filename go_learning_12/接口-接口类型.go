package main

import "fmt"

/*
接口是一种类型,类似于哈希,数组,切片等基本数据类型
是一种抽象的类型

interface 是一组 method的集合,是鸭子类型编程风格
的一种体现.接口做的事情就像是定义一个协议(规则),只
要一台机器有洗衣服和甩干的功能,我就称它为洗衣机.
不关心属性(数据),只关心行为(方法)

为了保护你的go语言职业生涯,请牢记接口interface 是
一种类型

比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？
go 语言中为了解决类似上面的问题,就设计了接口这个概念.
接口区别于我们之前的所有的数据类型,接口是一种抽象的类型.
当你看到一个接口类型的值时,你不知道它是什么,唯一知道的是
通过它的方法能做什么

*/

/*
go 语言提倡面向接口编程
	接口是一个或者多个方法签名的集合
	任何类型的方法集合中只要拥有该接口 "对应的全部方法" 签名(入参和返回值),
	就表示它 "实现"了该接口,无须在该类型上显式声明实现了哪个接口,
	这称为Structural Typing。
	所谓对应方法,是指有相同名称,参数列表(不包括参数名)以及返回值
	当然,该类型还可以有其他方法

	接口只有方法声明,没有实现,没有数据字段
	接口可以匿名嵌入其他接口,或嵌入到结构中.
	对象赋值给接口时,会发生拷贝,而接口内部存储的是指向这个复制品的指针,即
	无法修改复制品的状态,也无法获取指针.
	只有当接口存储的类型和对象都为nil时,接口才等于nil.
	接口调用不会做receiver的自动转换
	接口同样支持匿名字段方法
	接口也可实现类似OOP中的多态
	空接口可以作为任何类型数据的容器
	一个类型可实现多个接口
	接口命名习惯以 er 结尾


每个接口由数个方法组成,接口的定义格式如下:
	type 接口类型名 interface{
		方法名1(参数列表1) 返回值列表1
		方法名1(参数列表2) 返回值列表2
		...
	}

其中:
	1. 接口名:使用type将接口定义为自定义的类型名.
go语言的接口在命名时,一般会在单词后面添加er,如有写操作的接口叫做Writer,
有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义
	2.方法名:当方法名首字母是大写且这个接口类型名首字母也是大写时,这个方法
可以被接口所在的包(package)之外的代码访问
	3.参数列表,返回值列表:参数列表和返回值列表中的参数变量名可以省略.
*/

/*
实现接口的条件:
	一个对象只要全部实现了接口中的方法,那么就实现了这个接口.换句话说,
接口就是一个需要实现的方法列表.

只要实现了接口中的所有方法,就实现了这个接口

接口类型变量:
	作用:
	接口类型变量能够存储所有实现了该接口的实例.
	例如上面的示例中,Sayer类型的变量能够存储dog和cat类型的变量

有点类似Python中的抽象类

使用值接收者实现接口之后,不管是dog结构体还是结构体指针 *dog类型的变量都可以
赋值给该接口变量.因为go语言中有对指针类型变量的求值的语法糖,dog指针fugui
内部会自动求值 *fugui

*/

// 下面是个面试题: 无法编译通过
type People interface {
	Speak(string) string
}

type Student struct {}

func (stu *Student) Speak(think string) (talk string) {
	if think == "sb" {
		talk = "你是个大帅比"
	} else {
		talk = "您好"
	}
	return
}

func main() {
	var peo People = &Student{}
	think := "sb"
	fmt.Println(peo.Speak(think))
}

//type Mover interface {
//	move()
//}
//
//type dog struct {}
//
//func (d dog) move() {
//	fmt.Println("狗会动")
//}
//
//func main() {
//	var x Mover
//	var wangcai = dog{} // 旺财是dog类型
//	x = wangcai         // x可以接收dog类型
//	var fugui = &dog{}  // 富贵是*dog类型
//	x = fugui           // x可以接收*dog类型
//	x.move()
//}