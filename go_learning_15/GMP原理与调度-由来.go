package main

import (
	"fmt"
	"os"
	"runtime/trace"
)

/*
单进程时代不需要调度器

一切的软件都是跑在操作系统上,真正用来干活的是CPU.
早期的操作系统每个程序就是一个进程,直到一个程序
运行完,才能进行下一个进程,就是 单进程时代.

一切的程序只能串行发生.

但新的问题就又出现了,进程拥有太多的资源,进程的创建,切换,
销毁都会占用很长的时间,CPU虽然利用起来了,但如果进程过多,
CPU有很大的一部分都被用来进行进程调度了.

很明显,CPU调度切换的是进程和线程.尽管线程看起来很美好,但
实际上多线程开发设计会变得更加复杂,要考虑很多同步竞争的等
问题,如锁,竞争冲突等.

多进程多线程已经提高了系统的并发能力,但是在当今互联网高并发
场景下,为每个任务都创建一个线程是不现实的,因为会消耗大量的内存
(进程虚拟内存会占用4GB[32位操作系统]),而线程也要大约4MB.

大量的进程/线程出现了新的问题:
	高内存占用
	调度的高消耗CPU

好了,然后工程师们就发现,其实一个线程分为内核态线程和用户态线程

一个用户态线程必须要绑定一个内核态线程,但是CPU并不知道有用户态
线程的存在,它只知道它运行的是一个内核态线程(Linux的PCB进程控制块)

这样,我们再去细化去分类一下,内核线程依然叫"线程(thread)",用户线程
叫协程(co-routine)

看到这里,我们就要开脑洞了,既然一个协程可以绑定一个线程,那么能不能
多个协程绑定一个或者多个线程上呢?

协程和线程的映射关系:
	N : 1  关系

N个协程绑定1个线程,优点是协程在用户态线程即完成切换,不会陷入到内核态,
这种切换非常的轻量快速.但也有很大的缺点,1个进程的所有协程都绑定在1个线程上.

缺点:
	某个程序用不了硬件的多核加速能力
	一旦某协程阻塞,造成线程阻塞,本进程的其他协程都无法执行了,根本就没有
并发的能力了.

一个协程绑定一个线程,这种最容易实现.协程的调度都由CPU完成了,不存在N:1缺点.
缺点:
	协程的创建,删除和切换的代价都由CPU完成,优点略显昂贵了.


协程跟线程是有区别的,线程由CPU调度是抢占式的,协程由用户态调度是协作式的,一个协程
让出CPU后,才执行下一个协程.

go为了提供更容易使用的并发方法,使用了goroutine和channel.
goroutine来自协程的概念,让一组可复用的函数运行在一组线程之上,即使有
协程阻塞,该线程的其他协程也可以被runtime调度,转移到其他可运行的线程
上.最关键的是,程序员看不到这些底层的细节.,这就降低了编程的难度,提供了
更容易的并发.

go中,协程被称为goroutine,它非常轻量,一个goroutine只占几KB,并且这
几KB就足够goroutine运行完,这就能在有限的内存空间内支持大量goroutine
,支持了更多的并发.虽然一个goroutine的栈只占几KB,但实际是可伸缩的,如果需要
更多的内存,runtime会自动为goroutine分配.

goroutine特点:
	占用内存更小(几kb)
	调度更灵活(runtime调度)


总结:
	Go调度器很轻量也很简单,足以撑起goroutine的调度工作.并且让Go具有了
原生(强大)并发的能力.Go调度本质是把大量的goroutine分配到少量线程上去执行,
并利用多核并行,实现更强大的并发.
*/

func main() {
	// 创建trace文件
	f, err := os.Create("trace.out")
	if err != nil {
		panic(err)
	}

	defer f.Close()

	// 启动trace goroutine
	err = trace.Start(f)
	if err != nil {
		panic(err)
	}
	defer trace.Stop()

	// main
	fmt.Println("Hello World")
}
